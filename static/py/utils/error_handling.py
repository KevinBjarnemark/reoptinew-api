
from .logging import logger
from rest_framework.response import Response
from static.py.utils.inspect_stack import get_file_name_of_caller


def throw_error(status_code, error_message, log=None, error_details=None):
    """
    Throws customized errors in a minimalistic and clean way. Used
    for sending error messages to the frontend customized for user
    experience, while minimizing exposure of backend logic. It also
    allows optional logging for debugging purposes and supports detailed
    error reporting when needed.

    Args:
        status_code (int): HTTP status code for the response.
        error_message (str): Main error message (frontend).
        log (str, optional): Log message to record. Defaults to None.
        error_details (dict or list, optional): Additional error details.
        Defaults to None.

    Returns:
        Response: DRF Response object with error data.
    """
    if log:
        # Get the file name of the caller
        caller_file = get_file_name_of_caller(2)
        occurred_in = f"(Occurred in {caller_file} by throw_error()) "
        logger.error(
            f"{occurred_in} {{"
            f"  'status_code': {status_code},"
            f"  'error_message': '{error_message}',"
            f"  'log': '{log}',"
            f"  'error_details': {error_details},"
            f"}}"
        )

    def process_errors(errors):
        """
        This function processes the error structure (typically from
        serializer.errors) to extract error codes while handling
        unexpected data formats gracefully. It ensures only sanitized and
        approved error codes are sent to the client, logging unexpected
        structures for debugging purposes.

        Args:
            errors (dict, list, or any): The error structure generated by
            the serializer during validation.

        Returns:
            dict: A sanitized error response containing only error codes,
            mapped to custom error messages if applicable, or "unknown_error"
            for unexpected cases.

            Example:
            {
                "username": ["This field is missing."],
                "password": [
                    "This field is below the minimum required length."
                ]
            }
        """
        # Map error codes to custom error messages
        error_code_mapping = {
            "blank": "This field is missing.",
            "invalid": "The input provided is invalid.",
            "max_length": "This field exceeds the maximum allowed length.",
            "min_length": "This field is below the minimum required length.",
            "unknown_error": "An unexpected error occurred.",
            # Catch non-field errors
            "non_field_errors": {"invalid": "Invalid credentials"},
        }

        def map_error_code(code, is_non_field=False):
            """
            Map an error code to a custom message or fallback to a generic
            message.
            """
            if is_non_field:
                return (
                    error_code_mapping.get("non_field_errors", {}).get(
                        code, error_code_mapping["unknown_error"])
                )
            return (
                error_code_mapping.get(
                    code, error_code_mapping["unknown_error"]
                )
            )

        if isinstance(errors, dict):
            sanitized_errors = {}  # result
            for field, messages in errors.items():
                if isinstance(messages, list):
                    # Handle the expected list of errors
                    sanitized_errors[field] = []
                    for err in messages:
                        error_code = getattr(err, "code", "unknown_error")
                        if field == "non_field_errors":
                            sanitized_errors["non_field_errors"].append(
                                map_error_code(error_code, True)
                            )
                        else:
                            sanitized_errors[field].append(
                                map_error_code(error_code)
                            )
                else:
                    # Handle unexpected non-list messages
                    logger.error(
                        f"Unexpected structure for field '{field}': {messages}"
                    )
                    sanitized_errors[field] = [
                        error_code_mapping["unknown_error"]
                    ]
            return sanitized_errors
        else:
            # Handle unexpected non-list messages
            logger.error(f"Unexpected structure for errors: {errors}")
            return {"non_field_errors": [error_code_mapping["unknown_error"]]}

    error_response = {"error_message": error_message}
    if error_details:
        sanitized_details = process_errors(error_details)
        error_response["error_details"] = sanitized_details

    return Response(error_response, status=status_code)
